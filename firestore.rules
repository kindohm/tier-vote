rules_version = '2';
service cloud.firestore {
	match /databases/{database}/documents {

		function isSignedIn() {
			return request.auth != null;
		}

		function isAdmin() {
			return isSignedIn() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
		}

		// Core tier lists collection (lowercase)
		match /tierlists/{listId} {
			allow read: if isSignedIn();
			// TEMP: allow any signed-in user to create until admin doc IDs are normalized to uid.
			allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
			// TEMP: broaden update so participants can add themselves to users. Harden later.
			allow update: if isSignedIn();
			allow delete: if isAdmin();

			// Votes subcollection (if/when used under lowercase path)
			match /votes/{voteId} {
				allow read: if isSignedIn();
				allow create, update: if isSignedIn()
					&& request.resource.data.userId == request.auth.uid
					&& request.resource.data.listId == listId
					&& request.resource.data.keys().hasAll(['userId','tier','listId','itemId']);
			}

			// Participants subcollection - tracks who has voted in this list
			match /participants/{userId} {
				allow read: if isSignedIn();
				allow create, update: if isSignedIn()
					&& request.resource.data.userId == request.auth.uid
					&& userId == request.auth.uid
					&& request.resource.data.keys().hasAll(['userId'])
					&& 'firstParticipatedAt' in request.resource.data;
			}

			// Messages subcollection for chat
			match /messages/{msgId} {
				allow read: if isSignedIn();
				allow create: if isSignedIn()
					&& request.resource.data.userId == request.auth.uid
					&& request.resource.data.keys().hasAll(['userId','text','createdAt'])
					&& request.resource.data.text is string
					&& request.resource.data.text.size() > 0
					&& request.resource.data.userName is string || request.resource.data.userName == null
					&& request.resource.data.photoURL is string || request.resource.data.photoURL == null;
			}
		}

		// Legacy camel-case parent for existing votes logic
		match /tierLists/{listId} {
			allow read: if isSignedIn();
			// Prevent creating new lists here; only read/update if already exists & user is owner/admin
			allow create: if false; // enforce new lists use /tierlists
			allow update: if isSignedIn() && (isAdmin() || resource.data.createdBy == request.auth.uid);
			allow delete: if isAdmin();

			match /votes/{voteId} {
				allow read: if isSignedIn();
				allow create, update: if isSignedIn()
					&& request.resource.data.userId == request.auth.uid
					&& request.resource.data.listId == listId
					&& request.resource.data.keys().hasAll(['userId','tier','listId','itemId']);
			}

			// Participants subcollection - tracks who has voted in this list (legacy path)
			match /participants/{userId} {
				allow read: if isSignedIn();
				allow create, update: if isSignedIn()
					&& request.resource.data.userId == request.auth.uid
					&& userId == request.auth.uid
					&& request.resource.data.keys().hasAll(['userId'])
					&& 'firstParticipatedAt' in request.resource.data;
			}

			// Messages subcollection for chat (legacy camel-case parent)
			match /messages/{msgId} {
				allow read: if isSignedIn();
				allow create: if isSignedIn()
					&& request.resource.data.userId == request.auth.uid
					&& request.resource.data.keys().hasAll(['userId','text','createdAt'])
					&& request.resource.data.text is string
					&& request.resource.data.text.size() > 0
					&& (request.resource.data.userName is string || request.resource.data.userName == null)
					&& (request.resource.data.photoURL is string || request.resource.data.photoURL == null);
			}
		}

		// Admins list
		match /admins/{adminId} {
			allow read: if isSignedIn();
			allow create, update, delete: if isAdmin();
		}

		// Generic collection group access for votes aggregation (read-only)
		match /{path=**}/votes/{voteId} {
			allow read: if isSignedIn();
		}

		// Collection group access for participants (for finding lists a user has participated in)
		match /{path=**}/participants/{userId} {
			allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
		}
	}
}
